package core

import chisel3._
import chisel3.util._
import bundles._
import constants.ALUOp

object IPat {
  // Chapter 34. RV32/64G Instruction Set Listings
  // RV32I Base Instruction Set
  val LUI    = BitPat("b??????? ????? ????? ??? ????? 01101 11")
  val AUIPC  = BitPat("b??????? ????? ????? ??? ????? 00101 11")
  val JAL    = BitPat("b??????? ????? ????? ??? ????? 11011 11")
  val JALR   = BitPat("b??????? ????? ????? 000 ????? 11001 11")
  val BEQ    = BitPat("b??????? ????? ????? 000 ????? 11000 11")
  val BNE    = BitPat("b??????? ????? ????? 001 ????? 11000 11")
  val BLT    = BitPat("b??????? ????? ????? 100 ????? 11000 11")
  val BGE    = BitPat("b??????? ????? ????? 101 ????? 11000 11")
  val BLTU   = BitPat("b??????? ????? ????? 110 ????? 11000 11")
  val BGEU   = BitPat("b??????? ????? ????? 111 ????? 11000 11")
  val LB     = BitPat("b??????? ????? ????? 000 ????? 00000 11")
  val LH     = BitPat("b??????? ????? ????? 001 ????? 00000 11")
  val LW     = BitPat("b??????? ????? ????? 010 ????? 00000 11")
  val LBU    = BitPat("b??????? ????? ????? 100 ????? 00000 11")
  val LHU    = BitPat("b??????? ????? ????? 101 ????? 00000 11")
  val SB     = BitPat("b??????? ????? ????? 000 ????? 01000 11")
  val SH     = BitPat("b??????? ????? ????? 001 ????? 01000 11")
  val SW     = BitPat("b??????? ????? ????? 010 ????? 01000 11")
  val ADDI   = BitPat("b??????? ????? ????? 000 ????? 00100 11")
  val SLTI   = BitPat("b??????? ????? ????? 010 ????? 00100 11")
  val SLTIU  = BitPat("b??????? ????? ????? 011 ????? 00100 11")
  val XORI   = BitPat("b??????? ????? ????? 100 ????? 00100 11")
  val ORI    = BitPat("b??????? ????? ????? 110 ????? 00100 11")
  val ANDI   = BitPat("b??????? ????? ????? 111 ????? 00100 11")
  val SLLI   = BitPat("b0000000 ????? ????? 001 ????? 00100 11")
  val SRLI   = BitPat("b0000000 ????? ????? 101 ????? 00100 11")
  val SRAI   = BitPat("b0100000 ????? ????? 101 ????? 00100 11")
  val ADD    = BitPat("b0000000 ????? ????? 000 ????? 01100 11")
  val SUB    = BitPat("b0100000 ????? ????? 000 ????? 01100 11")
  val SLL    = BitPat("b0000000 ????? ????? 001 ????? 01100 11")
  val SLT    = BitPat("b0000000 ????? ????? 010 ????? 01100 11")
  val SLTU   = BitPat("b0000000 ????? ????? 011 ????? 01100 11")
  val XOR    = BitPat("b0000000 ????? ????? 100 ????? 01100 11")
  val SRL    = BitPat("b0000000 ????? ????? 101 ????? 01100 11")
  val SRA    = BitPat("b0100000 ????? ????? 101 ????? 01100 11")
  val OR     = BitPat("b0000000 ????? ????? 110 ????? 01100 11")
  val AND    = BitPat("b0000000 ????? ????? 111 ????? 01100 11")
  val FENCE  = BitPat("b??????? ????? ????? 000 ????? 00011 11")
  val EALL   = BitPat("b0000000 00000 00000 000 00000 11100 11")
  val EBREAK = BitPat("b0000000 00001 00000 000 00000 11100 11")

  // RV32M Standard Extension
  val MUL    = BitPat("0000001 ????? ????? 000 ????? 01100 11")
  val MULH   = BitPat("0000001 ????? ????? 001 ????? 01100 11")
  val MULHSU = BitPat("0000001 ????? ????? 010 ????? 01100 11")
  val MULHU  = BitPat("0000001 ????? ????? 011 ????? 01100 11")
  val DIV    = BitPat("0000001 ????? ????? 100 ????? 01100 11")
  val DIVU   = BitPat("0000001 ????? ????? 101 ????? 01100 11")
  val REM    = BitPat("0000001 ????? ????? 110 ????? 01100 11")
  val REMU   = BitPat("0000001 ????? ????? 111 ????? 01100 11")
}

object IFmt {
  val WIDTH = log2Ceil(6).W

  val R = 0.U(WIDTH)
  val I = 1.U(WIDTH)
  val S = 2.U(WIDTH)
  val B = 3.U(WIDTH)
  val U = 4.U(WIDTH)
  val J = 5.U(WIDTH)
}

object ITable {
  import IPat._
  import OperType._

  val T = true.B
  val F = false.B

  // format, oper1, oper2, WE, ALU_OP, Branch Type
  val default = List(F, F, F, ALUOp.Add)
  val table   = Array(
    ADD  -> List(IFmt.R, Reg, Reg, T, ALUOp.Add, BrType.None),
    ADDI -> List(IFmt.I, Reg, Imm, T, ALUOp.Add, BrType.None),
    LUI  -> List(IFmt.U, Imm, Zero, T, ALUOp.Add, BrType.None),
    LW   -> List(IFmt.I, Reg, Imm, T, ALUOp.Add, BrType.None),
    LBU  -> List(IFmt.I, Reg, Imm, T, ALUOp.Add, BrType.None),
    SW   -> List(IFmt.S, Reg, Imm, F, ALUOp.Add, BrType.None),
    SB   -> List(IFmt.S, Reg, Imm, F, ALUOp.Add, BrType.None),
    JALR -> List(IFmt.I, Reg, Imm, T, ALUOp.Add, BrType.JALR)
  )
}

class IDU extends Module {
  val io = IO(new Bundle {
    val inst    = Input(UInt(32.W))
    val decoded = new DecodedBundle
  })

  // Registers
  val rd  = io.inst(11, 7)
  val rs1 = io.inst(19, 15)
  val rs2 = io.inst(24, 20)

  // Immediates
  val immI = Fill(20, io.inst(31)) ## io.inst(31, 20)
  val immS = Fill(20, io.inst(31)) ## io.inst(31, 25) ## io.inst(11, 7)
  val immB = Fill(20, io.inst(31)) ## io.inst(31) ## io.inst(7) ## io.inst(30, 25)
  val immU = io.inst(31, 12) ## Fill(12, 0.U)
  val immJ = Fill(12, io.inst(31)) ## io.inst(31) ## io.inst(20) ## io.inst(30, 21)

  // Decode
  val fmt :: oper1_type :: oper2_type :: (we: Bool) :: alu_op :: Nil =
    ListLookup(io.inst, ITable.default, ITable.table)

  // Choose immediate
  val imm = MuxLookup(fmt, immI)(
    Seq(
      IFmt.I -> immI,
      IFmt.S -> immS,
      IFmt.B -> immB,
      IFmt.U -> immU,
      IFmt.J -> immJ
    )
  )

  // IO
  io.decoded.alu_oper1_type := oper1_type
  io.decoded.alu_oper2_type := oper2_type
  io.decoded.rs1        := rs1
  io.decoded.rs2        := rs2
  io.decoded.imm        := imm
  io.decoded.rd         := rd
  io.decoded.rd_we         := we
  io.decoded.alu_op     := alu_op
}
