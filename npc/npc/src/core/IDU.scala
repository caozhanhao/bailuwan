package core

import chisel3._
import chisel3.util._
import bundles.DecodedBundle
import constants.ALUOp

object IPat {
  // Chapter 34. RV32/64G Instruction Set Listings
  // RV32I Base Instruction Set
  val LUI    = BitPat("b??????? ????? ????? ??? ????? 01101 11")
  val AUIPC  = BitPat("b??????? ????? ????? ??? ????? 00101 11")
  val JAL    = BitPat("b??????? ????? ????? ??? ????? 11011 11")
  val JALR   = BitPat("b??????? ????? ????? 000 ????? 11001 11")
  val BEQ    = BitPat("b??????? ????? ????? 000 ????? 11000 11")
  val BNE    = BitPat("b??????? ????? ????? 001 ????? 11000 11")
  val BLT    = BitPat("b??????? ????? ????? 100 ????? 11000 11")
  val BGE    = BitPat("b??????? ????? ????? 101 ????? 11000 11")
  val BLTU   = BitPat("b??????? ????? ????? 110 ????? 11000 11")
  val BGEU   = BitPat("b??????? ????? ????? 111 ????? 11000 11")
  val LB     = BitPat("b??????? ????? ????? 000 ????? 00000 11")
  val LH     = BitPat("b??????? ????? ????? 001 ????? 00000 11")
  val LW     = BitPat("b??????? ????? ????? 010 ????? 00000 11")
  val LBU    = BitPat("b??????? ????? ????? 100 ????? 00000 11")
  val LHU    = BitPat("b??????? ????? ????? 101 ????? 00000 11")
  val SB     = BitPat("b??????? ????? ????? 000 ????? 01000 11")
  val SH     = BitPat("b??????? ????? ????? 001 ????? 01000 11")
  val SW     = BitPat("b??????? ????? ????? 010 ????? 01000 11")
  val ADDI   = BitPat("b??????? ????? ????? 000 ????? 00100 11")
  val SLTI   = BitPat("b??????? ????? ????? 010 ????? 00100 11")
  val SLTIU  = BitPat("b??????? ????? ????? 011 ????? 00100 11")
  val XORI   = BitPat("b??????? ????? ????? 100 ????? 00100 11")
  val ORI    = BitPat("b??????? ????? ????? 110 ????? 00100 11")
  val ANDI   = BitPat("b??????? ????? ????? 111 ????? 00100 11")
  val SLLI   = BitPat("b0000000 ????? ????? 001 ????? 00100 11")
  val SRLI   = BitPat("b0000000 ????? ????? 101 ????? 00100 11")
  val SRAI   = BitPat("b0100000 ????? ????? 101 ????? 00100 11")
  val ADD    = BitPat("b0000000 ????? ????? 000 ????? 01100 11")
  val SUB    = BitPat("b0100000 ????? ????? 000 ????? 01100 11")
  val SLL    = BitPat("b0000000 ????? ????? 001 ????? 01100 11")
  val SLT    = BitPat("b0000000 ????? ????? 010 ????? 01100 11")
  val SLTU   = BitPat("b0000000 ????? ????? 011 ????? 01100 11")
  val XOR    = BitPat("b0000000 ????? ????? 100 ????? 01100 11")
  val SRL    = BitPat("b0000000 ????? ????? 101 ????? 01100 11")
  val SRA    = BitPat("b0100000 ????? ????? 101 ????? 01100 11")
  val OR     = BitPat("b0000000 ????? ????? 110 ????? 01100 11")
  val AND    = BitPat("b0000000 ????? ????? 111 ????? 01100 11")
  val FENCE  = BitPat("b??????? ????? ????? 000 ????? 00011 11")
  val EALL   = BitPat("b0000000 00000 00000 000 00000 11100 11")
  val EBREAK = BitPat("b0000000 00001 00000 000 00000 11100 11")

  // RV32M Standard Extension
  val MUL    = BitPat("0000001 ????? ????? 000 ????? 01100 11")
  val MULH   = BitPat("0000001 ????? ????? 001 ????? 01100 11")
  val MULHSU = BitPat("0000001 ????? ????? 010 ????? 01100 11")
  val MULHU  = BitPat("0000001 ????? ????? 011 ????? 01100 11")
  val DIV    = BitPat("0000001 ????? ????? 100 ????? 01100 11")
  val DIVU   = BitPat("0000001 ????? ????? 101 ????? 01100 11")
  val REM    = BitPat("0000001 ????? ????? 110 ????? 01100 11")
  val REMU   = BitPat("0000001 ????? ????? 111 ????? 01100 11")
}

object IFmt {
  val WIDTH = log2Ceil(6).W

  val R = 0.U(WIDTH)
  val I = 1.U(WIDTH)
  val S = 2.U(WIDTH)
  val B = 3.U(WIDTH)
  val U = 4.U(WIDTH)
  val J = 5.U(WIDTH)
}

object ITable {
  import IPat._

  val T = true.B
  val F = false.B

  val REG = 0.U
  val IMM = 1.U
  val ZERO = 2.U
  val PC = 3.U
  
  // format, oper1, oper2, WE, ALU_OP
  val default = List(F, F, F, ALUOp.Add)
  val table   = Array(
    ADD  -> List(IFmt.R, REG, REG, T, ALUOp.Add),
    ADDI -> List(IFmt.I, REG, IMM, T, ALUOp.Add),
    LUI  -> List(IFmt.U, IMM, ZERO, T, ALUOp.Add),
    LW   -> List(IFmt.I, REG, IMM, T, ALUOp.Add),
    LBU  -> List(IFmt.I, REG, IMM, T, ALUOp.Add),
    SW   -> List(IFmt.S, REG, IMM, F, ALUOp.Add),
    SB   -> List(IFmt.S, REG, IMM, F, ALUOp.Add),
    JALR -> List(IFmt.I, REG, IMM, T, ALUOp.Add)
  )
}

class IDU extends Module {
  val io = IO(new Bundle {
    val inst    = Input(UInt(32.W))
    val decoded = new DecodedBundle
  })

  // Registers
  val rd     = io.inst(11, 7)
  val rs1    = io.inst(19, 15)
  val rs2    = io.inst(24, 20)

  // Immediates
  val immI = Fill(20, io.inst(31)) ## io.inst(31, 20)
  val immS = Fill(20, io.inst(31)) ## io.inst(31, 25) ## io.inst(11, 7)
  val immB = Fill(20, io.inst(31)) ## io.inst(31) ## io.inst(7) ## io.inst(30, 25)
  val immU = io.inst(31, 12) ## Fill(12, 0.U)
  val immJ = Fill(12, io.inst(31)) ## io.inst(31) ## io.inst(20) ## io.inst(30, 21)

  // Decode
  val fmt :: oper1_type :: oper2_type :: (we : Bool) :: alu_op :: Nil =
    ListLookup(io.inst, ITable.default, ITable.table)

  // Choose immediate
  val imm = MuxLookup(fmt, immI)(Seq(
    IFmt.I -> immI,
    IFmt.S -> immS,
    IFmt.B -> immB,
    IFmt.U -> immU,
    IFmt.J -> immJ
  ))

  // ALU Operands
  val oper1 = MuxLookup(oper1_type, rs1)(Seq(
    ITable.REG -> rs1,
    ITable.IMM -> imm,
    ITable.ZERO -> 0.U
  ))

  val oper2 = MuxLookup(oper2_type, rs2)(Seq(
    ITable.REG -> rs2,
    ITable.IMM -> imm,
    ITable.ZERO -> 0.U
  ))

  // IO
  io.decoded.oper1 := oper1
  io.decoded.oper2 := oper2
  io.decoded.alu_op := alu_op
  io.decoded.dest := Mux(we, rd, 0.U)
  io.decoded.imm := imm
}
